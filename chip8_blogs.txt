模拟器入门-chip8实现记录

导言:

chip8最早是在70年代在comsmac vip上开发的一款解释器/编程语言. 但是不同于现代的lua/python等解释语言, 它使用的十六进制指令码写起来更像汇编或是机器语言, 这使得它很合适作为开始其他硬件模拟器之前的入门项目(例如gameboy模拟器)

chip8在发明之后的数十年时间里衍生出了多种变体. 由于实现差异, 这些变体之间不是完全兼容的. 
这次我们制作的是最开始运行在comsmac vip上的原始chip8. 

在开始编写本模拟器之前, 可以先阅读以下参考材料:

维基百科, 包含chip8指令集列表
https://en.wikipedia.org/wiki/CHIP-8

<Guide to making a CHIP-8 emulator> chip8模拟器制作指南
该指南非常全面, 但是没有具体的代码实现
https://tobiasvl.github.io/blog/write-a-chip-8-emulator/

chip8的测试rom 其中包含了很多chip8和之后衍生版本实现上的差异
https://github.com/Timendus/chip8-test-suite

本文在这些材料的基础上为仅熟悉高级语言的读者提供了一些低级别的概念解释, 并展示了一些具体实现
实现代码是用面向过程的c++编写的, 应该很容易能移植到其他平台

另外需要注意的是, 在编写此类低级语言/硬件模拟器之前, 作者几乎没有接触过相关知识, 文中所提到的概念/术语不一定完全准确. 为了编写出健壮/完成度高的模拟器, 请对比多篇资料参看

在开始之前的一些typedef
'''c++
using type = uint8_t;
using word = uint16_t;
'''

指令格式:
chip8的指令是16位的, 即2个byte, 4个Half byte
指令的第一个Half byte指示指令的类型
后面剩下3个Half byte可以分别表示表示寄存器/立即数(硬编码的常量数值)

指令表中一般使用以下表述方式:
X, Y标记表示指令使用的寄存器, N, NN, NNN则分别表示编码到指令中的4位,8位,12位立即数, 或者说数值字面量, 常量

例如:
指令6XNN, 执行效果是将8位立即数NN写入到寄存器Vx中
```c++
byte x = (byte)((IR & 0x0F00) >> 8);
byte nn = (byte)(IR & 0x00FF);
reg[x] = nn;
```
对于读取到的指令60AB, 执行效果是reg[0]=0xAB

完整的指令列表请查看资料中的链接

memroy内存:
chip8的原始实现使用0x1000(即4096 byte)大小的ram, 其中0x200前的ram被保留.
在原始机器上, 这段空间用于储存chip8的本体软件, 之后的空间则用于储存需要运行的程序与数据, 所有字节都是可读写的. 
在现代实现中, 一般利用这段空间保留字体数据等

由于ram最大只有0x1000, 所以我们只需要0-0xFFF范围的内存地址值即可访问整个ram
在实现上, 我们可以把ram视为一个字节数组:
'''c++
byte ram[0xFFF]{};
'''

通用寄存器:
chip8包含16个8位通用寄存器V0-VF, 其中VF在某些指令中兼用作储存特殊情况的标志.
寄存器是用于在指令运行过程中暂存数据的容器, 我们可以把寄存器简单的实现为变量:
'''
// 声明寄存器
byte reg[16]{};

// 伪代码, 展示了一条假指令的动作
// 使用V0寄存器储存V1与V2之和并以VF指示结果是否溢出, 对于不同的指令操作, vf有不同的设置规则
void instr_add()
{
	int r = reg[0x1] + reg[0x2]
	reg[0x0] = r & 0xFF;
	reg[0xF] = r > 0xFF;
}
'''

程序计数器PC:
PC是一个特殊的16位寄存器, 用于储存内存地址. 可以简单的将其视为ram数组的自增长索引. 
程序在运行时通过PC从ram读取一条指令, 之后自动增长指向下一条指令.
一些特殊指令, 例如无条件跳转指令会把目标地址直接写入到PC寄存器.
PC的值也可以被压入和从栈中弹出, 用于临时保存指令的执行位置方便稍后跳转回来
```c++
// 如前所述, 保留0x200之前的地址
word PC = 0x200;

// 伪代码, 演示一下基本流程
while(true)
{
	// 获取一条指令同时增长PC
	word instr = (ram[PC++] << 8) | ram[PC++];
	
	// 对指令进行处理, 处理过程中可能修改PC的值
	exe(instr);
	
	// ...
}
```

地址寄存器I:
I也是一个特殊的16位寄存器, 用于储存内存地址, 和PC一样, 它也可以看做是ram数组的索引
一般用于索引到目标地址的数据, 它不会被自动增长
在使用DXYN精灵绘制命令之前, 需要先令I指向需要绘制精灵的起始位置
```c++
word I;
```

栈:
https://gunkies.org/wiki/Subroutine

chip8包含一个深度为12的栈, 用于实现子程序调用
后面将会详细解释
'''c++
constexpr int STACK_DEEP = 12;
word stack[STACK_DEEP]{};

// 根据实现方式, 我们再使用一个sp来储存当前的栈顶索引
// 当然, 你可以直接使用std::stack之类的便利容器
byte SP;
'''

在高级语言中, 我们将具有独立作用域, 允许输入/输出多个值的一段可复用的代码称之为函数
高级语言中的函数调用非常简单, 定义之后使用 func_name(args, ...) 语法即可

高级语言的函数功能即是在chip8以及其他类似的汇编系统中的子程序(Subroutine)之上实现的

chip8具有2条特殊指令:
2NNN 将当前PC的值压栈并跳转到12位地址NNN(即令PC=NNN)
00EE 弹出栈顶的值并重新赋值给PC

子程序的编写:
在ram中找一个合适的入口位置并从此位置开始编写指令
子程序一般与入口程序是分离的, 为了执行子程序, 我们需要2NNN指令将完成以下两个动作:
	1.通过跳转命令跳转到子程序的入口位置NNN来执行子程序
	1.在跳转开始之前需要储存程序的原始执行位置, 为了能嵌套的执行子程序, 我们利用栈先入后出的特性储存地址
在子程序的中间或是末尾需要跳出时添加一条00EE指令来恢复程序原先的执行位置

执行过程:
1.解释器读取到一条2NNN指令, 此时PC在读取指令后已经自动增长, 指向下一条指令了
1.2NNN指令将PC的值压栈, 同时将PC赋值为立即数NNN
1.解释器继续执行, 由于之前PC被赋值为NNN, 所以程序会从NNN开始向后执行, 即开始执行子程序, 同时PC会继续增长
1.在执行子程序的过程中, 也可能读取到新的2NNN指令, 此时就相当于嵌套执行. 由于栈最大有12个位置, 所有最多可以嵌套12级
1.解释器读取到一条00EE指令, 此时将先前缓存的PC值弹出栈顶并赋给PC, PC恢复到上一次执行2NNN时的后一条命令并继续执行

计时器:
chip8具有2个计时器
延时计时器 可读写
声音计时器 只写

它们固定以60hz的速度递减
声音计时器在大于0时, chip8自带的蜂鸣器将持续发声

需要注意的是指令FX0A会阻塞指令的执行并等待按键, 在此期间计时器不受影响

在chip8程序中延迟计时器的典型用法是使用指令FX07设置计时器值并检查倒计时

屏幕显示:
chip8具有一个128*64尺寸的黑白屏幕
'''
constexpr int SCREEN_WIDTH = 128;
constexpr int SCREEN_HEIGHT = 64;
'''

在内存充足时, 我们可以使用bool[]来表示
'''bool vram[SCREEN_WIDTH * SCREEN_HEIGHT]{};'''
或是每个bit表示一个像素:
'''byte vram[SCREEN_WIDTH * SCREEN_HEIGHT / 8]{};'''

下文的实现中使用每个bit表示一个像素

使用指令DXYN可以将内存中的一块区域解释为精灵并通过xor运算绘制到屏幕上
稍后有详细解释

